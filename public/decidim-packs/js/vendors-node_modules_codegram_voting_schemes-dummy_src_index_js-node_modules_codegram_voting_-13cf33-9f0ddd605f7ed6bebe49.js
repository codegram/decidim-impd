(self["webpackChunkdecidim"] = self["webpackChunkdecidim"] || []).push([["vendors-node_modules_codegram_voting_schemes-dummy_src_index_js-node_modules_codegram_voting_-13cf33"],{

/***/ "./node_modules/@codegram/voting_schemes-dummy/src/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@codegram/voting_schemes-dummy/src/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TrusteeWrapperAdapter": function() { return /* reexport safe */ _trustee_wrapper_adapter__WEBPACK_IMPORTED_MODULE_0__.TrusteeWrapperAdapter; },
/* harmony export */   "VoterWrapperAdapter": function() { return /* reexport safe */ _voter_wrapper_adapter__WEBPACK_IMPORTED_MODULE_1__.VoterWrapperAdapter; }
/* harmony export */ });
/* harmony import */ var _trustee_wrapper_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trustee_wrapper_adapter */ "./node_modules/@codegram/voting_schemes-dummy/src/trustee_wrapper_adapter.js");
/* harmony import */ var _voter_wrapper_adapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./voter_wrapper_adapter */ "./node_modules/@codegram/voting_schemes-dummy/src/voter_wrapper_adapter.js");






/***/ }),

/***/ "./node_modules/@codegram/voting_schemes-dummy/src/trustee_wrapper.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@codegram/voting_schemes-dummy/src/trustee_wrapper.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CREATED": function() { return /* binding */ CREATED; },
/* harmony export */   "KEY_CEREMONY": function() { return /* binding */ KEY_CEREMONY; },
/* harmony export */   "KEY_CEREMONY_ENDED": function() { return /* binding */ KEY_CEREMONY_ENDED; },
/* harmony export */   "TALLY": function() { return /* binding */ TALLY; },
/* harmony export */   "TALLY_ENDED": function() { return /* binding */ TALLY_ENDED; },
/* harmony export */   "CREATE_ELECTION": function() { return /* binding */ CREATE_ELECTION; },
/* harmony export */   "START_KEY_CEREMONY": function() { return /* binding */ START_KEY_CEREMONY; },
/* harmony export */   "KEY_CEREMONY_STEP_1": function() { return /* binding */ KEY_CEREMONY_STEP_1; },
/* harmony export */   "END_KEY_CEREMONY": function() { return /* binding */ END_KEY_CEREMONY; },
/* harmony export */   "START_TALLY": function() { return /* binding */ START_TALLY; },
/* harmony export */   "TALLY_CAST": function() { return /* binding */ TALLY_CAST; },
/* harmony export */   "TALLY_SHARE": function() { return /* binding */ TALLY_SHARE; },
/* harmony export */   "END_TALLY": function() { return /* binding */ END_TALLY; },
/* harmony export */   "TrusteeWrapper": function() { return /* binding */ TrusteeWrapper; }
/* harmony export */ });
const CREATED = 0;
const KEY_CEREMONY = 1;
const KEY_CEREMONY_ENDED = 2;
const TALLY = 3;
const TALLY_ENDED = 4;

const CREATE_ELECTION = "create_election";
const START_KEY_CEREMONY = "start_key_ceremony";
const KEY_CEREMONY_STEP_1 = "key_ceremony.step_1";
const END_KEY_CEREMONY = "end_key_ceremony";
const START_TALLY = "start_tally";
const TALLY_CAST = "tally.cast";
const TALLY_SHARE = "tally.share";
const END_TALLY = "end_tally";

/**
 * This is just a dummy implementation of a possible `TrusteeWrapper`.
 * It is based on the dummy voting schema that we are using in the Bulletin Board.
 */
class TrusteeWrapper {
  /**
   * Initializes the class with the given params.
   *
   * @constructor
   * @param {Object} params - An object that contains the initialization params.
   * - {String} trusteeId - The unique id of a trustee.
   */
  constructor({ trusteeId }) {
    this.trusteeId = trusteeId;
    this.status = CREATED;
    this.electionPublicKey = 0;
  }

  /**
   * Process the message and update the wrapper status.
   *
   * @param {String} messageType - The message type.
   * @param {Object} decodedData - An object with the data to process.
   *
   * @returns {Object|undefined}
   */
  processMessage(messageType, decodedData) {
    switch (this.status) {
      case CREATED: {
        if (messageType === START_KEY_CEREMONY) {
          this.status = KEY_CEREMONY;
          this.electionPublicKey = Math.floor(50 + Math.random() * 200) * 2 + 1;

          return {
            messageType: KEY_CEREMONY_STEP_1,
            content: JSON.stringify({
              election_public_key: this.electionPublicKey,
              owner_id: this.trusteeId,
            }),
          };
        }
        break;
      }
      case KEY_CEREMONY: {
        if (messageType === END_KEY_CEREMONY) {
          this.status = KEY_CEREMONY_ENDED;
        }
        break;
      }
      case KEY_CEREMONY_ENDED: {
        if (messageType === START_TALLY) {
          this.status = TALLY;
        }
        break;
      }
      case TALLY: {
        if (messageType === TALLY_CAST) {
          const contests = JSON.parse(decodedData.content);
          for (const [question, answers] of Object.entries(contests)) {
            for (const [answer, value] of Object.entries(answers)) {
              contests[question][answer] =
                (value % this.electionPublicKey) * this.electionPublicKey;
            }
          }

          return {
            messageType: TALLY_SHARE,
            content: JSON.stringify({
              owner_id: this.trusteeId,
              contests,
            }),
          };
        } else if (messageType === END_TALLY) {
          this.status = TALLY_ENDED;
        }
        break;
      }
    }
  }

  /**
   * Whether the trustee wrapper is in a fresh state or no.
   *
   * @returns {boolean}
   */
  isFresh() {
    return this.status === CREATED;
  }

  /**
   * Returns the wrapper state in a string format.
   *
   * @returns {String}
   */
  backup() {
    return JSON.stringify(this);
  }

  /**
   * Restore the trustee state from the given state string.
   *
   * @param {string} state - As string with the wrapper state retrieved from the backup method.
   * @returns {boolean}
   */
  restore(state) {
    if (!this.isFresh()) {
      console.warn("Restore not needed");
      return false;
    }

    const result = JSON.parse(state);
    if (result.trusteeId !== this.trusteeId) {
      console.warn("Invalid trustee id");
      return false;
    }

    if (result.status === CREATED) {
      console.warn("Invalid restored status");
      return false;
    }

    try {
      Object.assign(this, result);
    } catch (error) {
      console.error(error);
      return false;
    }

    return true;
  }

  /**
   * Whether the key ceremony process is done or not.
   * @returns {Boolean}
   */
  isKeyCeremonyDone() {
    return this.status >= KEY_CEREMONY_ENDED;
  }

  /**
   * Whether the tally process is done or not.
   * @returns {Boolean}
   */
  isTallyDone() {
    return this.status >= TALLY_ENDED;
  }
}


/***/ }),

/***/ "./node_modules/@codegram/voting_schemes-dummy/src/trustee_wrapper_adapter.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@codegram/voting_schemes-dummy/src/trustee_wrapper_adapter.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TrusteeWrapperAdapter": function() { return /* binding */ TrusteeWrapperAdapter; }
/* harmony export */ });
/* harmony import */ var _trustee_wrapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trustee_wrapper */ "./node_modules/@codegram/voting_schemes-dummy/src/trustee_wrapper.js");


/**
 * This is just a dummy implementation of a possible `TrusteeWrapperAdapter`.
 * It is based on the dummy voting scheme that we are using in the Bulletin Board.
 */
class TrusteeWrapperAdapter {
  /**
   * Initializes the class with the given params.
   *
   * @constructor
   * @param {Object} params - An object that contains the initialization params.
   * - {String} trusteeId - The unique id of a trustee.
   */
  constructor({ trusteeId }) {
    this.trusteeId = trusteeId;
    this.wrapper = new _trustee_wrapper__WEBPACK_IMPORTED_MODULE_0__.TrusteeWrapper({ trusteeId });
  }

  /**
   * Setup the trustee wrapper.
   *
   * @returns {Promise<undefined>}
   */
  setup() {}

  /**
   * Process the message and update the wrapper status.
   *
   * @param {String} messageType - The message type.
   * @param {Object} decodedData - An object with the data to process.
   *
   * @returns {Promise<Object|undefined>}
   */
  processMessage(messageType, decodedData) {
    return this.wrapper.processMessage(messageType, decodedData);
  }

  /**
   * Whether the trustee wrapper is in a fresh state or no.
   *
   * @returns {Promise<Boolean>}
   */
  isFresh() {
    return this.wrapper.isFresh();
  }

  /**
   * Returns the wrapper state in a string format.
   *
   * @returns {Promise<String>}
   */
  backup() {
    return this.wrapper.backup();
  }

  /**
   * Restore the trustee state from the given state string.
   *
   * @param {string} state - As string with the wrapper state retrieved from the backup method.
   * @returns {Promise<Boolean>}
   */
  restore(state) {
    return this.wrapper.restore(state);
  }

  /**
   * Whether the key ceremony process is done or not.
   * @returns {Promise<Boolean>}
   */
  isKeyCeremonyDone() {
    return this.wrapper.isKeyCeremonyDone();
  }

  /**
   * Whether the tally process is done or not.
   * @returns {Promise<Boolean>}
   */
  isTallyDone() {
    return this.wrapper.isTallyDone();
  }
}


/***/ }),

/***/ "./node_modules/@codegram/voting_schemes-dummy/src/voter_wrapper.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@codegram/voting_schemes-dummy/src/voter_wrapper.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CREATE_ELECTION": function() { return /* binding */ CREATE_ELECTION; },
/* harmony export */   "END_KEY_CEREMONY": function() { return /* binding */ END_KEY_CEREMONY; },
/* harmony export */   "WAIT_TIME_MS": function() { return /* binding */ WAIT_TIME_MS; },
/* harmony export */   "VoterWrapper": function() { return /* binding */ VoterWrapper; }
/* harmony export */ });
const CREATE_ELECTION = "create_election";
const END_KEY_CEREMONY = "end_key_ceremony";

/**
 * This is just a dummy implementation of a possible `VoterWrapper`.
 * It is based on the dummy voting schema that we are using in the Bulletin Board.
 */

const WAIT_TIME_MS = 500; // 0.5s

class VoterWrapper {
  constructor({ voterId, waitTime }) {
    this.voterId = voterId;
    this.jointElectionKey = null;
    this.contests = {};
    this.waitTime = waitTime ?? WAIT_TIME_MS;
  }

  /**
   * Process the message and update the wrapper status.
   *
   * @param {String} messageType - The message type.
   * @param {Object} decodedData - An object with the data to process.
   *
   * @returns {undefined}
   */
  processMessage(messageType, decodedData) {
    switch (messageType) {
      case CREATE_ELECTION: {
        this.contests = decodedData.description.contests;
        break;
      }
      case END_KEY_CEREMONY: {
        const content = JSON.parse(decodedData.content);
        this.jointElectionKey = content.joint_election_key;
        break;
      }
    }
  }

  /**
   * Converts the given vote into an auditable ballot and an encrypted Ballot. As the process is very fast,
   * it simulates the delay of the encryption process.
   *
   * @param {Object} plainVote - An object with the choosen answers for each question.
   * @param {String} ballotStyle - The ballot style identifier.
   *
   * @private
   * @returns {Promise<Object|undefined>}
   */
  async encrypt(plainVote, _ballotStyle) {
    return new Promise((resolve) => setTimeout(resolve, WAIT_TIME_MS)).then(
      () => {
        if (!this.jointElectionKey) {
          console.warn("Invalid election status.");
          return;
        }

        const auditableData = this.createAuditableBallot(plainVote);
        const encryptedData = JSON.stringify(
          this.createEncryptedData(JSON.parse(JSON.stringify(auditableData)))
        );

        return { auditableData, encryptedData };
      }
    );
  }

  /**
   * Encrypts the given vote into an object with the format expected by the Dummy voting scheme,
   * using the silly encryption defined by the scheme for each answer ((1|0) + random * jointElectionKey).
   * Returns the auditable vote.
   *
   * @param {Object} vote - An object with the choosen answers for each question.
   *
   * @private
   * @returns {<Object>}
   */
  createAuditableBallot(vote) {
    /* eslint-disable camelcase */
    return {
      ballot_style: "ballot-style",
      contests: this.contests.map(({ object_id, ballot_selections }) => {
        return {
          object_id,
          ballot_selections: ballot_selections.map((ballotSelection) => {
            const random = Math.random();
            const plaintext =
              vote[object_id] &&
              vote[object_id].includes(ballotSelection.object_id)
                ? 1
                : 0;

            return {
              object_id: ballotSelection.object_id,
              ciphertext:
                plaintext + Math.floor(random * 500) * this.jointElectionKey,
              random,
              plaintext,
            };
          }),
        };
      }),
    };
    /* eslint-enable camelcase */
  }

  /**
   * Creates an encrypted data.
   *
   * @param {Object} vote - An object with the encrypted vote.
   *
   * @private
   * @returns {<Object>}
   */
  createEncryptedData(vote) {
    const encryptedBallot = this.removeAuditInformation(vote);
    return encryptedBallot;
  }

  /**
   * Removes the 'random' and 'plaintext' fields from the auditable ballot.
   *
   * @param {Object} ballot - An auditable ballot.
   *
   * @private
   * @returns {<Object>}
   */
  removeAuditInformation(ballot) {
    /* eslint-disable camelcase */
    ballot.contests.map((contest) => {
      return contest.ballot_selections.map((ballot_selection) => {
        delete ballot_selection.random;
        delete ballot_selection.plaintext;

        return ballot_selection;
      });
    });

    return ballot;
    /* eslint-enable camelcase */
  }
}


/***/ }),

/***/ "./node_modules/@codegram/voting_schemes-dummy/src/voter_wrapper_adapter.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@codegram/voting_schemes-dummy/src/voter_wrapper_adapter.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VoterWrapperAdapter": function() { return /* binding */ VoterWrapperAdapter; }
/* harmony export */ });
/* harmony import */ var _voter_wrapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./voter_wrapper */ "./node_modules/@codegram/voting_schemes-dummy/src/voter_wrapper.js");


/**
 * This is just a dummy implementation of a possible `VoterWrapperAdapter`.
 * It is based on the dummy voting scheme that we are using in the Bulletin Board.
 */
class VoterWrapperAdapter {
  /**
   * Initializes the class with the given params.
   *
   * @constructor
   * @param {Object} params - An object that contains the initialization params.
   * - {String} voterId - The unique id of a trustee.
   * - {String} waitTime - The time to wait to simulate the real encryption time.
   * -
   */
  constructor({ voterId, waitTime }) {
    this.voterId = voterId;
    this.wrapper = new _voter_wrapper__WEBPACK_IMPORTED_MODULE_0__.VoterWrapper({ voterId, waitTime });
  }

  /**
   * Setup the voter wrapper.
   *
   * @returns {Promise<undefined>}
   */
  setup() {}

  /**
   * Processes the message and updates the wrapper status.
   *
   * @param {String} messageType - The message type.
   * @param {Object} decodedData - An object with the data to process.
   *
   * @returns {Promise<Object|undefined>}
   */
  processMessage(messageType, decodedData) {
    return this.wrapper.processMessage(messageType, decodedData);
  }

  /**
   * Encrypts the plain vote using the wrapper and returns an object with the
   * encrypted data and the auditable data known as ballot.
   *
   * @param {Object} plainVote - An object with the choosen answers for each question.
   * @param {String} ballotStyle - The ballot style identifier.
   *
   * @private
   * @returns {Promise<Object|undefined>}
   */
  encrypt(plainVote, ballotStyle) {
    return this.wrapper.encrypt(plainVote, ballotStyle);
  }
}


/***/ }),

/***/ "./node_modules/@codegram/voting_schemes-electionguard/src/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@codegram/voting_schemes-electionguard/src/index.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TrusteeWrapperAdapter": function() { return /* reexport safe */ _trustee_wrapper_adapter__WEBPACK_IMPORTED_MODULE_0__.TrusteeWrapperAdapter; },
/* harmony export */   "VoterWrapperAdapter": function() { return /* reexport safe */ _voter_wrapper_adapter__WEBPACK_IMPORTED_MODULE_1__.VoterWrapperAdapter; }
/* harmony export */ });
/* harmony import */ var _trustee_wrapper_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trustee_wrapper_adapter */ "./node_modules/@codegram/voting_schemes-electionguard/src/trustee_wrapper_adapter.js");
/* harmony import */ var _voter_wrapper_adapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./voter_wrapper_adapter */ "./node_modules/@codegram/voting_schemes-electionguard/src/voter_wrapper_adapter.js");






/***/ }),

/***/ "./node_modules/@codegram/voting_schemes-electionguard/src/trustee_wrapper_adapter.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@codegram/voting_schemes-electionguard/src/trustee_wrapper_adapter.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TrusteeWrapperAdapter": function() { return /* binding */ TrusteeWrapperAdapter; }
/* harmony export */ });
/* harmony import */ var _wrapper_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrapper_adapter */ "./node_modules/@codegram/voting_schemes-electionguard/src/wrapper_adapter.js");


/**
 * This implements the Electionguard Trustee Wrapper Adapter using a web worker
 * that executes python code compiled through `pyodide`.
 * @extends WrapperAdapter
 */
class TrusteeWrapperAdapter extends _wrapper_adapter__WEBPACK_IMPORTED_MODULE_0__.WrapperAdapter {
  /**
   * Initializes the class with the given params.
   *
   * @constructor
   * @param {Object} params - An object that contains the initialization params.
   * - {String} trusteeId - The unique id of a trustee.
   */
  constructor({ trusteeId, workerUrl }) {
    super();

    this.trusteeId = trusteeId;
    this.worker = new Worker(workerUrl);
  }

  /**
   * Setup the trustee wrapper.
   *
   * @returns {Promise<undefined>}
   */
  setup() {
    return this.processPythonCodeOnWorker(
      `
        from js import trustee_id
        from bulletin_board.electionguard.trustee import Trustee
        trustee = Trustee(trustee_id)
      `,
      {
        trustee_id: this.trusteeId,
      }
    );
  }

  /**
   * Process the message and update the wrapper status.
   *
   * @param {String} messageType - The message type.
   * @param {Object} decodedData - An object with the data to process.
   *
   * @returns {Promise<Object|undefined>}
   */
  async processMessage(messageType, decodedData) {
    const result = await this.processPythonCodeOnWorker(
      `
      import json
      from js import message_type, decoded_data
      trustee.process_message(message_type, json.loads(decoded_data))
    `,
      {
        message_type: messageType,
        decoded_data: JSON.stringify(decodedData),
      }
    );

    if (result && result.length > 0) {
      // eslint-disable-next-line camelcase
      const [{ message_type, content }] = result;
      return {
        messageType: message_type,
        content,
      };
    }
  }

  /**
   * Whether the trustee wrapper is in a fresh state or no.
   *
   * @returns {Promise<Boolean>}
   */
  isFresh() {
    return this.processPythonCodeOnWorker(
      `
      trustee.is_fresh()
    `
    );
  }

  /**
   * Returns the wrapper state in a string format.
   *
   * @returns {Promise<String>}
   */
  backup() {
    return this.processPythonCodeOnWorker(
      `
      trustee.backup().hex()
    `
    );
  }

  /**
   * Restore the trustee state from the given state string.
   *
   * @param {string} state - As string with the wrapper state retrieved from the backup method.
   * @returns {Promise<Boolean>}
   */
  restore(state) {
    return this.processPythonCodeOnWorker(
      `
      from js import state

      trustee = Trustee.restore(bytes.fromhex(state))
      True
    `,
      {
        state,
      }
    );
  }

  /**
   * Whether the key ceremony process is done or not.
   *
   * @returns {Promise<Boolean>}
   */
  isKeyCeremonyDone() {
    return this.processPythonCodeOnWorker(
      `
      trustee.is_key_ceremony_done()
    `
    );
  }

  /**
   * Whether the tally process is done or not.
   *
   * @returns {Promise<Boolean>}
   */
  isTallyDone() {
    return this.processPythonCodeOnWorker(
      `
      trustee.is_tally_done()
    `
    );
  }
}


/***/ }),

/***/ "./node_modules/@codegram/voting_schemes-electionguard/src/voter_wrapper_adapter.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@codegram/voting_schemes-electionguard/src/voter_wrapper_adapter.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VoterWrapperAdapter": function() { return /* binding */ VoterWrapperAdapter; }
/* harmony export */ });
/* harmony import */ var _wrapper_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrapper_adapter */ "./node_modules/@codegram/voting_schemes-electionguard/src/wrapper_adapter.js");


/**
 * This implements the Electionguard Voter Wrapper Adapter using a web worker
 * that executes python code compiled through `pyodide`.
 * @extends WrapperAdapter
 */
class VoterWrapperAdapter extends _wrapper_adapter__WEBPACK_IMPORTED_MODULE_0__.WrapperAdapter {
  /**
   * Initializes the class with the given params.
   *
   * @constructor
   * @param {Object} params - An object that contains the initialization params.
   * - {String} voterId - The unique id of a voter.
   */
  constructor({ voterId, workerUrl }) {
    super();

    this.voterId = voterId;
    this.worker = new Worker(workerUrl);
  }

  /**
   * Setup the voter wrapper.
   *
   * @returns {Promise<undefined>}
   */
  setup() {
    return this.processPythonCodeOnWorker(
      `
        from js import voter_id
        from bulletin_board.electionguard.voter import Voter
        voter = Voter(voter_id)
      `,
      {
        voter_id: this.voterId,
      }
    );
  }

  /**
   * Process the message and update the wrapper status.
   *
   * @param {String} messageType - The message type.
   * @param {Object} decodedData - An object with the data to process.
   *
   * @returns {Promise<Object|undefined>}
   */
  async processMessage(messageType, decodedData) {
    const result = await this.processPythonCodeOnWorker(
      `
      import json
      from js import message_type, decoded_data
      voter.process_message(message_type, json.loads(decoded_data))
    `,
      {
        message_type: messageType,
        decoded_data: JSON.stringify(decodedData),
      }
    );

    if (result && result[0]) {
      // eslint-disable-next-line camelcase
      const { message_type, content } = result[0];
      return {
        messageType: message_type,
        content,
      };
    }
  }

  /**
   * Encrypts the plain vote using the wrapper and returns an object with the
   * encrypted data and the auditable data known as ballot.
   *
   * @param {Object} plainVote - An object with the choosen answers for each question.
   * @param {String} ballotStyle - The ballot style identifier.
   *
   * @private
   * @returns {Promise<Object|undefined>}
   */
  async encrypt(plainVote, ballotStyle) {
    const [auditableData, encryptedData] = await this.processPythonCodeOnWorker(
      `
      from js import plain_vote, ballot_style
      voter.encrypt(plain_vote, ballot_style)
    `,
      {
        plain_vote: plainVote,
        ballot_style: ballotStyle,
      }
    );

    return { auditableData, encryptedData };
  }
}


/***/ }),

/***/ "./node_modules/@codegram/voting_schemes-electionguard/src/wrapper_adapter.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@codegram/voting_schemes-electionguard/src/wrapper_adapter.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WrapperAdapter": function() { return /* binding */ WrapperAdapter; }
/* harmony export */ });
/**
 * Common class used by any ElectionGuard adapter to run python code through web workers.
 */
class WrapperAdapter {
  /**
   * Runs an arbitrary python code in the web worker.
   *
   * @param {String} pythonCode - A string representing valid python code.
   * @param {Object} pythonData - An Object which values can be referenced from
   *                              the python code using the js module.
   * @private
   * @returns {Promise<Object>}
   */
  processPythonCodeOnWorker(pythonCode, pythonData) {
    return new Promise((resolve, reject) => {
      this.worker.onmessage = (event) => {
        resolve(event.data.results);
      };

      this.worker.onerror = (error) => {
        console.error(error);
        reject(error);
      };

      this.worker.postMessage({
        python: pythonCode,
        ...pythonData,
      });
    });
  }
}


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_codegram_voting_schemes-dummy_src_index_js-node_modules_codegram_voting_-13cf33-9f0ddd605f7ed6bebe49.js.map