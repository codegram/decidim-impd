(self["webpackChunkdecidim"] = self["webpackChunkdecidim"] || []).push([["vendors-node_modules_zeitiger_appendaround_appendAround_js-node_modules_morphdom_dist_morphdo-a91934"],{

/***/ "./node_modules/@zeitiger/appendaround/appendAround.js":
/*!*************************************************************!*\
  !*** ./node_modules/@zeitiger/appendaround/appendAround.js ***!
  \*************************************************************/
/***/ (function() {

/*! appendAround markup pattern. [c]2012, @scottjehl, Filament Group, Inc. MIT/GPL 
how-to:
	1. Insert potential element containers throughout the DOM
	2. give each container a data-set attribute with a value that matches all other containers' values
	3. Place your appendAround content in one of the potential containers
	4. Call appendAround() on that element when the DOM is ready
*/
(function( $ ){
	$.fn.appendAround = function(){
	  return this.each(function(){
      
	    var $self = $( this ),
	        att = "data-set",
	        $parent = $self.parent(), 
	        parent = $parent[ 0 ],
	        attval = $parent.attr( att ),
	        $set = $( "["+ att +"='" + attval + "']" );

		function isHidden( elem ){
			return $(elem).css( "display" ) === "none";
		}

		function appendToVisibleContainer(){
			if( isHidden( parent ) ){
				var found = 0;
				$set.each(function(){
					if( !isHidden( this ) && !found ){
						$self.appendTo( this );
						found++;
						parent = this;
					}
				});
	      	}
	    }
      
	    appendToVisibleContainer();
      
	    $(window).bind( "resize", appendToVisibleContainer );
      
	  });
	};
}( jQuery ));


/***/ }),

/***/ "./node_modules/attrobj/dist/attrobj.js":
/*!**********************************************!*\
  !*** ./node_modules/attrobj/dist/attrobj.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* global window */
function attrobj (key, el) {
  var values = {};
  Object.keys(el.dataset).forEach(function (data) {
    if (data.match(new RegExp("^" + key)) && data !== key) {
      var optionName = data.replace(key, '');
      var isGlobal = false;

      if (optionName.match(/^Global/)) {
        optionName = optionName.replace('Global', '');
        isGlobal = true;
      }

      optionName = "" + optionName[0].toLowerCase() + optionName.slice(1);

      if (isGlobal) {
        values[optionName] = window[el.dataset[data]];
      } else {
        values[optionName] = el.dataset[data];
      }

      if (typeof values[optionName] === 'undefined' || values[optionName] === '') {
        values[optionName] = true;
      }
    }
  });
  return values;
}

/* harmony default export */ __webpack_exports__["default"] = (attrobj);
//# sourceMappingURL=attrobj.js.map


/***/ }),

/***/ "./node_modules/aug/dist/aug.module.js":
/*!*********************************************!*\
  !*** ./node_modules/aug/dist/aug.module.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var l=function(){var l=[].slice.call(arguments);return l.unshift(!1),t.apply(null,l)};function t(){var t=[].slice.call(arguments),e=t[0],n={};return t.slice(1,t.length).forEach(function(r){Object.keys(r).forEach(function(a){if(!e||void 0!==t[1][a]){var c=r[a];n[a]=Array.isArray(c)||"object"!=typeof c||"object"!=typeof n[a]?c:(e?l.defaults:l)(n[a],c)}})}),n}l.defaults=function(){var l=[].slice.call(arguments);return l.unshift(!0),t.apply(null,l)};/* harmony default export */ __webpack_exports__["default"] = (l);
//# sourceMappingURL=aug.module.js.map


/***/ }),

/***/ "./node_modules/domassist/dist/domassist.js":
/*!**************************************************!*\
  !*** ./node_modules/domassist/dist/domassist.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addAttrs": function() { return /* binding */ addAttrs; },
/* harmony export */   "addClass": function() { return /* binding */ addClass; },
/* harmony export */   "append": function() { return /* binding */ append; },
/* harmony export */   "closest": function() { return /* binding */ closest; },
/* harmony export */   "delegate": function() { return /* binding */ delegate; },
/* harmony export */   "find": function() { return /* binding */ find; },
/* harmony export */   "findOne": function() { return /* binding */ findOne; },
/* harmony export */   "fire": function() { return /* binding */ fire; },
/* harmony export */   "hasClass": function() { return /* binding */ hasClass; },
/* harmony export */   "hide": function() { return /* binding */ hide; },
/* harmony export */   "hover": function() { return /* binding */ hover; },
/* harmony export */   "html": function() { return /* binding */ html; },
/* harmony export */   "isTouch": function() { return /* binding */ isTouch; },
/* harmony export */   "isWindow": function() { return /* binding */ isWindow; },
/* harmony export */   "matches": function() { return /* binding */ matches; },
/* harmony export */   "modify": function() { return /* binding */ modify; },
/* harmony export */   "off": function() { return /* binding */ off; },
/* harmony export */   "on": function() { return /* binding */ on; },
/* harmony export */   "once": function() { return /* binding */ once; },
/* harmony export */   "prefixedTransform": function() { return /* binding */ prefixedTransform; },
/* harmony export */   "ready": function() { return /* binding */ ready; },
/* harmony export */   "remove": function() { return /* binding */ remove; },
/* harmony export */   "removeClass": function() { return /* binding */ removeClass; },
/* harmony export */   "scrollableContainer": function() { return /* binding */ getScrollableContainer; },
/* harmony export */   "show": function() { return /* binding */ show; },
/* harmony export */   "styles": function() { return /* binding */ styles; },
/* harmony export */   "toArray": function() { return /* binding */ toArray; },
/* harmony export */   "toggleClass": function() { return /* binding */ toggleClass; }
/* harmony export */ });
function isWindow(obj) {
  return obj != null && obj === obj.window;
}

function find(selector, context) {
  if (context === void 0) {
    context = null;
  }

  if (selector instanceof HTMLElement || selector instanceof Node || isWindow(selector)) {
    return [selector];
  } else if (selector instanceof NodeList) {
    return [].slice.call(selector);
  } else if (typeof selector === 'string') {
    var startElement = context ? find(context)[0] : document;
    return [].slice.call(startElement.querySelectorAll(selector));
  }

  return [];
}

function addClass(selector, cls) {
  if (Array.isArray(selector)) {
    return selector.forEach(function (item) {
      return addClass(item, cls);
    });
  }

  var els = find(selector);

  if (els.length) {
    var clsArray = [].concat(cls);
    els.forEach(function (el) {
      clsArray.forEach(function (item) {
        el.classList.add(item);
      });
    });
    return els;
  }
}

function on(selector, event, cb, capture) {
  if (capture === void 0) {
    capture = false;
  }

  if (Array.isArray(selector)) {
    selector.forEach(function (item) {
      return on(item, event, cb, capture);
    });
    return;
  }

  var data = {
    cb: cb,
    capture: capture
  };

  if (!window._domassistevents) {
    window._domassistevents = {};
  }

  window._domassistevents["_" + event] = data;
  var el = find(selector);

  if (el.length) {
    el.forEach(function (item) {
      item.addEventListener(event, cb, capture);
    });
  }
}

function matches(el, selector) {
  var proto = Element.prototype;
  var match = false;
  var prefixes = ['matches', 'matchesSelector', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'];
  prefixes.forEach(function (prefix) {
    if (proto.hasOwnProperty(prefix)) {
      match = proto[prefix];
    }
  });

  if (match) {
    return el ? match.call(el, selector) : null;
  }
}

function closest(el, selector) {
  do {
    if (matches(el, selector)) {
      return el;
    }

    el = el.parentElement || el.parentNode;
  } while (el !== null && el.nodeType === 1);

  return null;
}

function delegate(el, event, selector, cb, capture) {
  if (capture === void 0) {
    capture = false;
  }

  on(el, event, function (e) {
    if (e.target && closest(e.target, selector)) {
      return cb(e);
    }
  }, capture);
}

function findOne(selector, el) {
  var found = find(selector, el);

  if (found.length) {
    return found[0];
  }

  return null;
}

// Check for the usage of native support for CustomEvents which is lacking
// completely on IE.
//

function canIuseNativeCustom() {
  try {
    var p = new CustomEvent('t', {
      detail: {
        a: 'b'
      }
    });
    return p.type === 't' && p.detail.a === 'b';
  } catch (e) {
    return false;
  }
} // Lousy polyfill for the Custom Event constructor for IE.


var IECustomEvent = function CustomEvent(type, params) {
  var e = document.createEvent('CustomEvent');

  if (params) {
    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
  } else {
    e.initCustomEvent(type, false, false, undefined);
  }

  return e;
};

var DomassistCustomEvent = false;

function fire(selector, type, params) {
  if (params === void 0) {
    params = {};
  }

  if (Array.isArray(selector)) {
    return selector.forEach(function (item) {
      return fire(item, type, params);
    });
  }

  if (!DomassistCustomEvent) {
    DomassistCustomEvent = canIuseNativeCustom() ? CustomEvent : IECustomEvent;
  }

  var els = find(selector);

  if (els.length) {
    if (params.bubbles !== false) {
      params.bubbles = true;
    }

    els.forEach(function (el) {
      var event = new DomassistCustomEvent(type, params);
      el.dispatchEvent(event);
    });
    return els;
  }
}

function hasClass(selector, cls) {
  var el = findOne(selector);

  if (!el) {
    return false;
  }

  return el.classList.contains(cls);
}

function hide(selector) {
  if (Array.isArray(selector)) {
    selector.forEach(function (item) {
      return hide(item);
    });
  }

  var els = find(selector);

  if (els.length) {
    els.forEach(function (el) {
      var currentDisplay = window.getComputedStyle(el).getPropertyValue('display');

      if (currentDisplay !== 'none') {
        el.dataset._currentDisplay = currentDisplay;
        el.style.display = 'none';
      }
    });
  }
}

function hover(el, enter, exit) {
  on(el, 'mouseenter', enter);
  on(el, 'mouseleave', exit);
}

function off(selector, event) {
  if (Array.isArray(selector)) {
    selector.forEach(function (item) {
      return off(item, event);
    });
  }

  if (!window._domassistevents) {
    window._domassistevents = {};
  }

  var data = window._domassistevents["_" + event];

  if (!data) {
    return;
  }

  var el = find(selector);

  if (el.length) {
    el.forEach(function (item) {
      item.removeEventListener(event, data.cb, data.capture);
    });
  }
}

function once(el, event, run, capture) {
  if (capture === void 0) {
    capture = false;
  }

  on(el, event, function (e) {
    off(el, event);
    run(e);
  }, capture);
}

var transform = null;
function prefixedTransform() {
  if (transform) {
    return transform;
  }

  var testEl = document.createElement('div');

  if (testEl.style.transform === null) {
    var vendors = ['Webkit', 'webkit', 'Moz', 'ms'];
    var property = null;

    for (var i = 0, len = vendors.length; i < len && !property; i++) {
      var tProperty = vendors[i] + "Transform";

      if (typeof testEl.style[tProperty] !== 'undefined') {
        property = tProperty;
      }
    }

    transform = property;
  } else {
    transform = 'transform';
  }

  return transform;
}

function removeClass(selector, cls) {
  if (Array.isArray(selector)) {
    return selector.forEach(function (item) {
      return removeClass(item, cls);
    });
  }

  var els = find(selector);

  if (els.length) {
    var clsArray = [].concat(cls);
    els.forEach(function (el) {
      clsArray.forEach(function (item) {
        el.classList.remove(item);
      });
    });
    return els;
  }
}

var SCROLLABLE_CONTAINER;

function getScrollableContainer() {
  if (SCROLLABLE_CONTAINER) {
    return SCROLLABLE_CONTAINER;
  }

  var documentElement = window.document.documentElement;
  var scrollableContainer;
  documentElement.scrollTop = 1;

  if (documentElement.scrollTop === 1) {
    documentElement.scrollTop = 0;
    scrollableContainer = documentElement;
  } else {
    scrollableContainer = document.body;
  }

  SCROLLABLE_CONTAINER = scrollableContainer;
  return scrollableContainer;
}

function show(selector) {
  if (Array.isArray(selector)) {
    selector.forEach(function (item) {
      return show(item);
    });
  }

  var els = find(selector);

  if (els.length) {
    els.forEach(function (el) {
      el.style.display = el.dataset._currentDisplay || 'block';
    });
  }
}

function toggleClass(selector, cls) {
  if (Array.isArray(selector)) {
    return selector.forEach(function (item) {
      return toggleClass(item, cls);
    });
  }

  var els = find(selector);

  if (els.length) {
    var clsArray = [].concat(cls);
    els.forEach(function (el) {
      clsArray.forEach(function (item) {
        el.classList.toggle(item);
      });
    });
    return els;
  }
}

var setupReady = function setupReady(callbacks) {
  return function (callback) {
    callbacks.push(callback);

    function execute() {
      while (callbacks.length) {
        var fn = callbacks.shift();

        if (typeof fn === 'function') {
          fn();
        }
      }
    }

    function loaded() {
      document.removeEventListener('DOMContentLoaded', loaded);
      execute();
    }

    setTimeout(function () {
      if (document.readyState !== 'loading') {
        return execute();
      }
    }, 0);
    document.addEventListener('DOMContentLoaded', loaded);
  };
};

var ready = setupReady([]);

function styles(selector, css) {
  if (Array.isArray(selector)) {
    selector.forEach(function (item) {
      return styles(item, css);
    });
  }

  var els = find(selector);

  if (els.length) {
    els.forEach(function (el) {
      Object.keys(css).forEach(function (key) {
        el.style[key] = css[key];
      });
    });
  }
}

function addAttrs(selector, attrs) {
  if (Array.isArray(selector)) {
    return selector.forEach(function (item) {
      return addAttrs(item, attrs);
    });
  }

  var els = find(selector);

  if (els.length) {
    els.forEach(function (item) {
      Object.keys(attrs).forEach(function (attr) {
        if (attr in item) {
          item[attr] = attrs[attr];
        } else {
          item.dataset[attr] = attrs[attr];
        }
      });
    });
  }

  return els;
}

function html(selector, value) {
  if (Array.isArray(selector)) {
    selector.forEach(function (item) {
      return html(item, value);
    });
  }

  var el = find(selector);

  if (el.length) {
    var length = el.length;

    for (var i = 0; i < length; i += 1) {
      el[i].innerHTML = value;
    }
  }
}

/* global DocumentTouch */
function isTouch() {
  return 'ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch;
}

function bindEvents(el, events) {
  Object.keys(events).forEach(function (event) {
    on(el, event, events[event]);
  });
}

function modify(selector, params) {
  if (Array.isArray(selector)) {
    selector.forEach(function (item) {
      return modify(item, params);
    });
  }

  var modules = {
    addClass: addClass,
    removeClass: removeClass,
    html: html,
    events: on,
    styles: styles
  };
  var els = find(selector);

  if (els.length) {
    els.forEach(function (el) {
      Object.keys(params).forEach(function (param, index) {
        if (param in modules) {
          if (param === 'events') {
            bindEvents(el, params[param]);
          }

          modules[param](el, params[param]);
        }
      });
    });
  }
}

function append(selector, value) {
  if (Array.isArray(selector)) {
    return selector.forEach(function (item) {
      return append(item, value);
    });
  }

  var els = find(selector);

  if (els.length) {
    els.forEach(function (el) {
      if (typeof value === 'string') {
        el.insertAdjacentHTML('beforeend', value);
      } else {
        el.appendChild(value);
      }
    });
  }
}

function toArray(value) {
  if (!value) {
    return [];
  }

  if (Array.isArray(value)) {
    return value;
  }

  if (value instanceof Node) {
    return [value];
  }

  return [].slice.call(value);
}

function remove(selector, context) {
  if (Array.isArray(selector)) {
    return selector.forEach(function (item) {
      return remove(item, context);
    });
  }

  var els = find(selector, context);

  if (els.length) {
    els.forEach(function (el) {
      if (el.prototype && el.prototype.remove) {
        el.remove();
      } else if (el.parentNode) {
        el.parentNode.removeChild(el);
      }
    });
  }
}

var domassist_default = {
  addClass: addClass,
  delegate: delegate,
  find: find,
  findOne: findOne,
  fire: fire,
  hasClass: hasClass,
  hide: hide,
  hover: hover,
  isWindow: isWindow,
  off: off,
  on: on,
  once: once,
  prefixedTransform: prefixedTransform,
  removeClass: removeClass,
  scrollableContainer: getScrollableContainer,
  show: show,
  matches: matches,
  toggleClass: toggleClass,
  closest: closest,
  ready: ready,
  styles: styles,
  addAttrs: addAttrs,
  html: html,
  isTouch: isTouch,
  modify: modify,
  append: append,
  toArray: toArray,
  remove: remove
};

/* harmony default export */ __webpack_exports__["default"] = (domassist_default);

//# sourceMappingURL=domassist.js.map


/***/ }),

/***/ "./node_modules/domodule/dist/domodule.module.js":
/*!*******************************************************!*\
  !*** ./node_modules/domodule/dist/domodule.module.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var domassist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! domassist */ "./node_modules/domassist/dist/domassist.js");
/* harmony import */ var attrobj__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! attrobj */ "./node_modules/attrobj/dist/attrobj.js");
/* harmony import */ var aug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aug */ "./node_modules/aug/dist/aug.module.js");
function s(t){return t.parentNode?JSON.parse(JSON.stringify(t.parentNode.dataset)).module?t.parentNode:s(t.parentNode):t}var r={find:domassist__WEBPACK_IMPORTED_MODULE_0__.find,findOne:domassist__WEBPACK_IMPORTED_MODULE_0__.findOne,on:domassist__WEBPACK_IMPORTED_MODULE_0__.on},d=function(){function t(e,o){return void 0===o&&(o=""),this.log("begin setup"),this.el=e,this.els={},this.options=(0,aug__WEBPACK_IMPORTED_MODULE_2__.default)({},this.defaults,(0,attrobj__WEBPACK_IMPORTED_MODULE_1__.default)("module",this.el)),this.moduleName=o||this.el.dataset.module,this.setUps={actions:[],named:[],options:[]},this.boundActionRouter=this.actionRouter.bind(this),this.preInit(),this.storeRef(),this.setupActions(),this.setupNamed(),this.verifyRequired(),this.postInit(),this.log("initalized"),t.debug&&(this.el.module=this),this}var e,o=t.prototype;return o.preInit=function(){},o.postInit=function(){},o.verifyRequired=function(){var t=this;return this.required==={}||(void 0!==this.required.options&&(this.setUps.options=Object.keys(this.options)),Object.keys(this.required).forEach(function(e){t.required[e].forEach(function(o){if(t.setUps[e].indexOf(o)<0)throw new Error(o+" is required as "+e+" for "+t.moduleName+", but is missing!")})})),this},o.setupActions=function(){var t=this;this.setupAction(this.el),this.find("[data-action]").forEach(function(e){s(e)===t.el&&t.setupAction(e)})},o.setupAction=function(e){if("true"!==e.dataset.domoduleActionProcessed){var o=t.parseAction(e),i=o.name,n=o.type;i&&("function"==typeof this[i]?(this.log(i+" bound"),this.storeSetUp(i,"actions"),r.on(e,n,this.boundActionRouter),e.dataset.domoduleActionProcessed="true"):this.log(i+" was registered, but there is no function set up"))}},o.actionRouter=function(e){var o=e.currentTarget,n=t.parseAction(o).name,s=(0,attrobj__WEBPACK_IMPORTED_MODULE_1__.default)("action",o);this[n].call(this,o,e,s)},o.setupNamed=function(){var t=this;this.find("[data-name]").forEach(function(e){s(e)===t.el&&(e.dataset.domoduleNameProcessed||(t.els[e.dataset.name]=e,t.storeSetUp(e.dataset.name,"named"),e.dataset.domoduleNameProcessed="true",e.dataset.domoduleOwner=t.id))})},o.storeRef=function(){if(void 0===window.domorefs&&(window.domorefs={}),void 0!==window.domorefs[this.el.dataset.moduleUid])return!1;this.id=this.uuid,this.el.dataset.moduleUid=this.id,window.domorefs[this.el.dataset.moduleUid]=this},o.find=function(t){return r.find(t,this.el)},o.findOne=function(t){return r.findOne(t,this.el)},o.findByName=function(t){return this.els[t]},o.getOption=function(t){return this.options[t]},o.storeSetUp=function(t,e){this.setUps[e].indexOf(t)<0&&this.setUps[e].push(t)},o.destroy=function(){var e=this;r.find("[data-action]",this.el.parentNode).forEach(function(o){if("true"===o.dataset.domoduleActionProcessed){var i=t.parseAction(o);o.removeEventListener(i.type,e.boundActionRouter),o.dataset.domoduleActionProcessed="false"}})},t.parseAction=function(t){var e=t.dataset,o=e.actionType;return{name:e.action,type:void 0===o?"click":o}},t.getInstance=function(t){if(t instanceof Node)return window.domorefs[t.dataset.moduleUid];throw new Error("getInstance expects a dom node")},t.register=function(e,o){"function"==typeof e&&(e=(o=e).prototype.constructor.name),window.domodules||(window.domodules={}),t.log("Registering "+e),window.domodules[e]=o},t.discover=function(e){if(void 0===e&&(e="body"),t.log("Discovering modules..."),window.domodules){var o;o=e instanceof Node?[e]:Array.isArray(e)?e:r.find(e);var i=[];return o.forEach(function(e){r.find("[data-module]",e).forEach(function(e){var o=e.dataset.module;if(o&&"function"==typeof window.domodules[o]){if("object"==typeof window.domorefs&&void 0!==window.domorefs[e.dataset.moduleUid])return;t.log(o+" found"),i.push(new window.domodules[o](e))}})}),i}t.log("No modules found")},o.log=function(e){t.log(this.constructor.name+": "+e)},t.log=function(e){t.debug&&console.log("[DOMODULE] "+e)},(e=[{key:"required",get:function(){return{}}},{key:"defaults",get:function(){return{}}},{key:"uuid",get:function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(t){var e=16*Math.random()|0;return("x"===t?e:3&e|8).toString(16)})}}])&&function(t,e){for(var o=0;o<e.length;o++){var i=e[o];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}(t.prototype,e),t}();d.debug="object"==typeof window.localStorage&&window.localStorage.getItem("DomoduleDebug"),d.autoDiscover=!0,window.addEventListener("DOMContentLoaded",function(){d.autoDiscover&&d.discover()});/* harmony default export */ __webpack_exports__["default"] = (d);
//# sourceMappingURL=domodule.module.js.map


/***/ }),

/***/ "./node_modules/morphdom/dist/morphdom-esm.js":
/*!****************************************************!*\
  !*** ./node_modules/morphdom/dist/morphdom-esm.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var DOCUMENT_FRAGMENT_NODE = 11;

function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;

    // document-fragments dont have attributes so lets not do anything
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }

    // update attributes on original DOM element
    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
        attr = toNodeAttrs[i];
        attrName = attr.name;
        attrNamespaceURI = attr.namespaceURI;
        attrValue = attr.value;

        if (attrNamespaceURI) {
            attrName = attr.localName || attrName;
            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);

            if (fromValue !== attrValue) {
                if (attr.prefix === 'xmlns'){
                    attrName = attr.name; // It's not allowed to set an attribute with the XMLNS namespace without specifying the `xmlns` prefix
                }
                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
            }
        } else {
            fromValue = fromNode.getAttribute(attrName);

            if (fromValue !== attrValue) {
                fromNode.setAttribute(attrName, attrValue);
            }
        }
    }

    // Remove any extra attributes found on the original DOM element that
    // weren't found on the target element.
    var fromNodeAttrs = fromNode.attributes;

    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
        attr = fromNodeAttrs[d];
        attrName = attr.name;
        attrNamespaceURI = attr.namespaceURI;

        if (attrNamespaceURI) {
            attrName = attr.localName || attrName;

            if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
                fromNode.removeAttributeNS(attrNamespaceURI, attrName);
            }
        } else {
            if (!toNode.hasAttribute(attrName)) {
                fromNode.removeAttribute(attrName);
            }
        }
    }
}

var range; // Create a range object for efficently rendering strings to elements.
var NS_XHTML = 'http://www.w3.org/1999/xhtml';

var doc = typeof document === 'undefined' ? undefined : document;
var HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');
var HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();

function createFragmentFromTemplate(str) {
    var template = doc.createElement('template');
    template.innerHTML = str;
    return template.content.childNodes[0];
}

function createFragmentFromRange(str) {
    if (!range) {
        range = doc.createRange();
        range.selectNode(doc.body);
    }

    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
}

function createFragmentFromWrap(str) {
    var fragment = doc.createElement('body');
    fragment.innerHTML = str;
    return fragment.childNodes[0];
}

/**
 * This is about the same
 * var html = new DOMParser().parseFromString(str, 'text/html');
 * return html.body.firstChild;
 *
 * @method toElement
 * @param {String} str
 */
function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which
      // createContextualFragment doesn't support
      // <template> support not available in IE
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }

    return createFragmentFromWrap(str);
}

/**
 * Returns true if two node's names are the same.
 *
 * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same
 *       nodeName and different namespace URIs.
 *
 * @param {Element} a
 * @param {Element} b The target element
 * @return {boolean}
 */
function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;

    if (fromNodeName === toNodeName) {
        return true;
    }

    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);

    // If the target element is a virtual DOM node or SVG node then we may
    // need to normalize the tag name before comparing. Normal HTML elements that are
    // in the "http://www.w3.org/1999/xhtml"
    // are converted to upper case
    if (fromCodeStart <= 90 && toCodeStart >= 97) { // from is upper and to is lower
        return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) { // to is upper and from is lower
        return toNodeName === fromNodeName.toUpperCase();
    } else {
        return false;
    }
}

/**
 * Create an element, optionally with a known namespace URI.
 *
 * @param {string} name the element name, e.g. 'div' or 'svg'
 * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of
 * its `xmlns` attribute or its inferred namespace.
 *
 * @return {Element}
 */
function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ?
        doc.createElement(name) :
        doc.createElementNS(namespaceURI, name);
}

/**
 * Copies the children of one DOM element to another DOM element
 */
function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
        var nextChild = curChild.nextSibling;
        toEl.appendChild(curChild);
        curChild = nextChild;
    }
    return toEl;
}

function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
        fromEl[name] = toEl[name];
        if (fromEl[name]) {
            fromEl.setAttribute(name, '');
        } else {
            fromEl.removeAttribute(name);
        }
    }
}

var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
        var parentNode = fromEl.parentNode;
        if (parentNode) {
            var parentName = parentNode.nodeName.toUpperCase();
            if (parentName === 'OPTGROUP') {
                parentNode = parentNode.parentNode;
                parentName = parentNode && parentNode.nodeName.toUpperCase();
            }
            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {
                if (fromEl.hasAttribute('selected') && !toEl.selected) {
                    // Workaround for MS Edge bug where the 'selected' attribute can only be
                    // removed if set to a non-empty value:
                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/
                    fromEl.setAttribute('selected', 'selected');
                    fromEl.removeAttribute('selected');
                }
                // We have to reset select element's selectedIndex to -1, otherwise setting
                // fromEl.selected using the syncBooleanAttrProp below has no effect.
                // The correct selectedIndex will be set in the SELECT special handler below.
                parentNode.selectedIndex = -1;
            }
        }
        syncBooleanAttrProp(fromEl, toEl, 'selected');
    },
    /**
     * The "value" attribute is special for the <input> element since it sets
     * the initial value. Changing the "value" attribute without changing the
     * "value" property will have no effect since it is only used to the set the
     * initial value.  Similar for the "checked" attribute, and "disabled".
     */
    INPUT: function(fromEl, toEl) {
        syncBooleanAttrProp(fromEl, toEl, 'checked');
        syncBooleanAttrProp(fromEl, toEl, 'disabled');

        if (fromEl.value !== toEl.value) {
            fromEl.value = toEl.value;
        }

        if (!toEl.hasAttribute('value')) {
            fromEl.removeAttribute('value');
        }
    },

    TEXTAREA: function(fromEl, toEl) {
        var newValue = toEl.value;
        if (fromEl.value !== newValue) {
            fromEl.value = newValue;
        }

        var firstChild = fromEl.firstChild;
        if (firstChild) {
            // Needed for IE. Apparently IE sets the placeholder as the
            // node value and vise versa. This ignores an empty update.
            var oldValue = firstChild.nodeValue;

            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {
                return;
            }

            firstChild.nodeValue = newValue;
        }
    },
    SELECT: function(fromEl, toEl) {
        if (!toEl.hasAttribute('multiple')) {
            var selectedIndex = -1;
            var i = 0;
            // We have to loop through children of fromEl, not toEl since nodes can be moved
            // from toEl to fromEl directly when morphing.
            // At the time this special handler is invoked, all children have already been morphed
            // and appended to / removed from fromEl, so using fromEl here is safe and correct.
            var curChild = fromEl.firstChild;
            var optgroup;
            var nodeName;
            while(curChild) {
                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
                if (nodeName === 'OPTGROUP') {
                    optgroup = curChild;
                    curChild = optgroup.firstChild;
                } else {
                    if (nodeName === 'OPTION') {
                        if (curChild.hasAttribute('selected')) {
                            selectedIndex = i;
                            break;
                        }
                        i++;
                    }
                    curChild = curChild.nextSibling;
                    if (!curChild && optgroup) {
                        curChild = optgroup.nextSibling;
                        optgroup = null;
                    }
                }
            }

            fromEl.selectedIndex = selectedIndex;
        }
    }
};

var ELEMENT_NODE = 1;
var DOCUMENT_FRAGMENT_NODE$1 = 11;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;

function noop() {}

function defaultGetNodeKey(node) {
  if (node) {
      return (node.getAttribute && node.getAttribute('id')) || node.id;
  }
}

function morphdomFactory(morphAttrs) {

    return function morphdom(fromNode, toNode, options) {
        if (!options) {
            options = {};
        }

        if (typeof toNode === 'string') {
            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML' || fromNode.nodeName === 'BODY') {
                var toNodeHtml = toNode;
                toNode = doc.createElement('html');
                toNode.innerHTML = toNodeHtml;
            } else {
                toNode = toElement(toNode);
            }
        }

        var getNodeKey = options.getNodeKey || defaultGetNodeKey;
        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
        var onNodeAdded = options.onNodeAdded || noop;
        var onBeforeElUpdated = options.onBeforeElUpdated || noop;
        var onElUpdated = options.onElUpdated || noop;
        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
        var onNodeDiscarded = options.onNodeDiscarded || noop;
        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
        var childrenOnly = options.childrenOnly === true;

        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.
        var fromNodesLookup = Object.create(null);
        var keyedRemovalList = [];

        function addKeyedRemoval(key) {
            keyedRemovalList.push(key);
        }

        function walkDiscardedChildNodes(node, skipKeyedNodes) {
            if (node.nodeType === ELEMENT_NODE) {
                var curChild = node.firstChild;
                while (curChild) {

                    var key = undefined;

                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {
                        // If we are skipping keyed nodes then we add the key
                        // to a list so that it can be handled at the very end.
                        addKeyedRemoval(key);
                    } else {
                        // Only report the node as discarded if it is not keyed. We do this because
                        // at the end we loop through all keyed elements that were unmatched
                        // and then discard them in one final pass.
                        onNodeDiscarded(curChild);
                        if (curChild.firstChild) {
                            walkDiscardedChildNodes(curChild, skipKeyedNodes);
                        }
                    }

                    curChild = curChild.nextSibling;
                }
            }
        }

        /**
         * Removes a DOM node out of the original DOM
         *
         * @param  {Node} node The node to remove
         * @param  {Node} parentNode The nodes parent
         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.
         * @return {undefined}
         */
        function removeNode(node, parentNode, skipKeyedNodes) {
            if (onBeforeNodeDiscarded(node) === false) {
                return;
            }

            if (parentNode) {
                parentNode.removeChild(node);
            }

            onNodeDiscarded(node);
            walkDiscardedChildNodes(node, skipKeyedNodes);
        }

        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future
        // function indexTree(root) {
        //     var treeWalker = document.createTreeWalker(
        //         root,
        //         NodeFilter.SHOW_ELEMENT);
        //
        //     var el;
        //     while((el = treeWalker.nextNode())) {
        //         var key = getNodeKey(el);
        //         if (key) {
        //             fromNodesLookup[key] = el;
        //         }
        //     }
        // }

        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future
        //
        // function indexTree(node) {
        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);
        //     var el;
        //     while((el = nodeIterator.nextNode())) {
        //         var key = getNodeKey(el);
        //         if (key) {
        //             fromNodesLookup[key] = el;
        //         }
        //     }
        // }

        function indexTree(node) {
            if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
                var curChild = node.firstChild;
                while (curChild) {
                    var key = getNodeKey(curChild);
                    if (key) {
                        fromNodesLookup[key] = curChild;
                    }

                    // Walk recursively
                    indexTree(curChild);

                    curChild = curChild.nextSibling;
                }
            }
        }

        indexTree(fromNode);

        function handleNodeAdded(el) {
            onNodeAdded(el);

            var curChild = el.firstChild;
            while (curChild) {
                var nextSibling = curChild.nextSibling;

                var key = getNodeKey(curChild);
                if (key) {
                    var unmatchedFromEl = fromNodesLookup[key];
                    // if we find a duplicate #id node in cache, replace `el` with cache value
                    // and morph it to the child node.
                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
                        morphEl(unmatchedFromEl, curChild);
                    } else {
                      handleNodeAdded(curChild);
                    }
                } else {
                  // recursively call for curChild and it's children to see if we find something in
                  // fromNodesLookup
                  handleNodeAdded(curChild);
                }

                curChild = nextSibling;
            }
        }

        function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
            // We have processed all of the "to nodes". If curFromNodeChild is
            // non-null then we still have some from nodes left over that need
            // to be removed
            while (curFromNodeChild) {
                var fromNextSibling = curFromNodeChild.nextSibling;
                if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {
                    // Since the node is keyed it might be matched up later so we defer
                    // the actual removal to later
                    addKeyedRemoval(curFromNodeKey);
                } else {
                    // NOTE: we skip nested keyed nodes from being removed since there is
                    //       still a chance they will be matched up later
                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
                }
                curFromNodeChild = fromNextSibling;
            }
        }

        function morphEl(fromEl, toEl, childrenOnly) {
            var toElKey = getNodeKey(toEl);

            if (toElKey) {
                // If an element with an ID is being morphed then it will be in the final
                // DOM so clear it out of the saved elements collection
                delete fromNodesLookup[toElKey];
            }

            if (!childrenOnly) {
                // optional
                if (onBeforeElUpdated(fromEl, toEl) === false) {
                    return;
                }

                // update attributes on original DOM element first
                morphAttrs(fromEl, toEl);
                // optional
                onElUpdated(fromEl);

                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
                    return;
                }
            }

            if (fromEl.nodeName !== 'TEXTAREA') {
              morphChildren(fromEl, toEl);
            } else {
              specialElHandlers.TEXTAREA(fromEl, toEl);
            }
        }

        function morphChildren(fromEl, toEl) {
            var curToNodeChild = toEl.firstChild;
            var curFromNodeChild = fromEl.firstChild;
            var curToNodeKey;
            var curFromNodeKey;

            var fromNextSibling;
            var toNextSibling;
            var matchingFromEl;

            // walk the children
            outer: while (curToNodeChild) {
                toNextSibling = curToNodeChild.nextSibling;
                curToNodeKey = getNodeKey(curToNodeChild);

                // walk the fromNode children all the way through
                while (curFromNodeChild) {
                    fromNextSibling = curFromNodeChild.nextSibling;

                    if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                        curToNodeChild = toNextSibling;
                        curFromNodeChild = fromNextSibling;
                        continue outer;
                    }

                    curFromNodeKey = getNodeKey(curFromNodeChild);

                    var curFromNodeType = curFromNodeChild.nodeType;

                    // this means if the curFromNodeChild doesnt have a match with the curToNodeChild
                    var isCompatible = undefined;

                    if (curFromNodeType === curToNodeChild.nodeType) {
                        if (curFromNodeType === ELEMENT_NODE) {
                            // Both nodes being compared are Element nodes

                            if (curToNodeKey) {
                                // The target node has a key so we want to match it up with the correct element
                                // in the original DOM tree
                                if (curToNodeKey !== curFromNodeKey) {
                                    // The current element in the original DOM tree does not have a matching key so
                                    // let's check our lookup to see if there is a matching element in the original
                                    // DOM tree
                                    if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {
                                        if (fromNextSibling === matchingFromEl) {
                                            // Special case for single element removals. To avoid removing the original
                                            // DOM node out of the tree (since that can break CSS transitions, etc.),
                                            // we will instead discard the current node and wait until the next
                                            // iteration to properly match up the keyed target element with its matching
                                            // element in the original tree
                                            isCompatible = false;
                                        } else {
                                            // We found a matching keyed element somewhere in the original DOM tree.
                                            // Let's move the original DOM node into the current position and morph
                                            // it.

                                            // NOTE: We use insertBefore instead of replaceChild because we want to go through
                                            // the `removeNode()` function for the node that is being discarded so that
                                            // all lifecycle hooks are correctly invoked
                                            fromEl.insertBefore(matchingFromEl, curFromNodeChild);

                                            // fromNextSibling = curFromNodeChild.nextSibling;

                                            if (curFromNodeKey) {
                                                // Since the node is keyed it might be matched up later so we defer
                                                // the actual removal to later
                                                addKeyedRemoval(curFromNodeKey);
                                            } else {
                                                // NOTE: we skip nested keyed nodes from being removed since there is
                                                //       still a chance they will be matched up later
                                                removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
                                            }

                                            curFromNodeChild = matchingFromEl;
                                        }
                                    } else {
                                        // The nodes are not compatible since the "to" node has a key and there
                                        // is no matching keyed node in the source tree
                                        isCompatible = false;
                                    }
                                }
                            } else if (curFromNodeKey) {
                                // The original has a key
                                isCompatible = false;
                            }

                            isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                            if (isCompatible) {
                                // We found compatible DOM elements so transform
                                // the current "from" node to match the current
                                // target DOM node.
                                // MORPH
                                morphEl(curFromNodeChild, curToNodeChild);
                            }

                        } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                            // Both nodes being compared are Text or Comment nodes
                            isCompatible = true;
                            // Simply update nodeValue on the original node to
                            // change the text value
                            if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                            }

                        }
                    }

                    if (isCompatible) {
                        // Advance both the "to" child and the "from" child since we found a match
                        // Nothing else to do as we already recursively called morphChildren above
                        curToNodeChild = toNextSibling;
                        curFromNodeChild = fromNextSibling;
                        continue outer;
                    }

                    // No compatible match so remove the old node from the DOM and continue trying to find a
                    // match in the original DOM. However, we only do this if the from node is not keyed
                    // since it is possible that a keyed node might match up with a node somewhere else in the
                    // target tree and we don't want to discard it just yet since it still might find a
                    // home in the final DOM tree. After everything is done we will remove any keyed nodes
                    // that didn't find a home
                    if (curFromNodeKey) {
                        // Since the node is keyed it might be matched up later so we defer
                        // the actual removal to later
                        addKeyedRemoval(curFromNodeKey);
                    } else {
                        // NOTE: we skip nested keyed nodes from being removed since there is
                        //       still a chance they will be matched up later
                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
                    }

                    curFromNodeChild = fromNextSibling;
                } // END: while(curFromNodeChild) {}

                // If we got this far then we did not find a candidate match for
                // our "to node" and we exhausted all of the children "from"
                // nodes. Therefore, we will just append the current "to" node
                // to the end
                if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
                    fromEl.appendChild(matchingFromEl);
                    // MORPH
                    morphEl(matchingFromEl, curToNodeChild);
                } else {
                    var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
                    if (onBeforeNodeAddedResult !== false) {
                        if (onBeforeNodeAddedResult) {
                            curToNodeChild = onBeforeNodeAddedResult;
                        }

                        if (curToNodeChild.actualize) {
                            curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                        }
                        fromEl.appendChild(curToNodeChild);
                        handleNodeAdded(curToNodeChild);
                    }
                }

                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
            }

            cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);

            var specialElHandler = specialElHandlers[fromEl.nodeName];
            if (specialElHandler) {
                specialElHandler(fromEl, toEl);
            }
        } // END: morphChildren(...)

        var morphedNode = fromNode;
        var morphedNodeType = morphedNode.nodeType;
        var toNodeType = toNode.nodeType;

        if (!childrenOnly) {
            // Handle the case where we are given two DOM nodes that are not
            // compatible (e.g. <div> --> <span> or <div> --> TEXT)
            if (morphedNodeType === ELEMENT_NODE) {
                if (toNodeType === ELEMENT_NODE) {
                    if (!compareNodeNames(fromNode, toNode)) {
                        onNodeDiscarded(fromNode);
                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
                    }
                } else {
                    // Going from an element node to a text node
                    morphedNode = toNode;
                }
            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node
                if (toNodeType === morphedNodeType) {
                    if (morphedNode.nodeValue !== toNode.nodeValue) {
                        morphedNode.nodeValue = toNode.nodeValue;
                    }

                    return morphedNode;
                } else {
                    // Text node to something else
                    morphedNode = toNode;
                }
            }
        }

        if (morphedNode === toNode) {
            // The "to node" was not compatible with the "from node" so we had to
            // toss out the "from node" and use the "to node"
            onNodeDiscarded(fromNode);
        } else {
            if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
                return;
            }

            morphEl(morphedNode, toNode, childrenOnly);

            // We now need to loop over any keyed nodes that might need to be
            // removed. We only do the removal if we know that the keyed node
            // never found a match. When a keyed node is matched up we remove
            // it out of fromNodesLookup and we use fromNodesLookup to determine
            // if a keyed node has been matched up or not
            if (keyedRemovalList) {
                for (var i=0, len=keyedRemovalList.length; i<len; i++) {
                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];
                    if (elToRemove) {
                        removeNode(elToRemove, elToRemove.parentNode, false);
                    }
                }
            }
        }

        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
            if (morphedNode.actualize) {
                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
            }
            // If we had to swap out the from node with a new node because the old
            // node was not compatible with the target node then we need to
            // replace the old DOM node in the original DOM tree. This is only
            // possible if the original DOM node was part of a DOM tree which
            // we know is the case if it has a parent node.
            fromNode.parentNode.replaceChild(morphedNode, fromNode);
        }

        return morphedNode;
    };
}

var morphdom = morphdomFactory(morphAttrs);

/* harmony default export */ __webpack_exports__["default"] = (morphdom);


/***/ }),

/***/ "./node_modules/select/src/select.js":
/*!*******************************************!*\
  !*** ./node_modules/select/src/select.js ***!
  \*******************************************/
/***/ (function(module) {

function select(element) {
    var selectedText;

    if (element.nodeName === 'SELECT') {
        element.focus();

        selectedText = element.value;
    }
    else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
        var isReadOnly = element.hasAttribute('readonly');

        if (!isReadOnly) {
            element.setAttribute('readonly', '');
        }

        element.select();
        element.setSelectionRange(0, element.value.length);

        if (!isReadOnly) {
            element.removeAttribute('readonly');
        }

        selectedText = element.value;
    }
    else {
        if (element.hasAttribute('contenteditable')) {
            element.focus();
        }

        var selection = window.getSelection();
        var range = document.createRange();

        range.selectNodeContents(element);
        selection.removeAllRanges();
        selection.addRange(range);

        selectedText = selection.toString();
    }

    return selectedText;
}

module.exports = select;


/***/ }),

/***/ "./node_modules/social-share-button/dist/social-share-button.js":
/*!**********************************************************************!*\
  !*** ./node_modules/social-share-button/dist/social-share-button.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var domodule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! domodule */ "./node_modules/domodule/dist/domodule.module.js");
/* harmony import */ var domassist__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! domassist */ "./node_modules/domassist/dist/domassist.js");



function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var BASE_URLS = {
  twitter: 'https://twitter.com/intent/tweet',
  facebook: 'https://www.facebook.com/sharer/sharer.php',
  gplus: 'https://plus.google.com/share',
  linkedin: 'https://www.linkedin.com/shareArticle',
  pinterest: 'https://pinterest.com/pin/create/button',
  reddit: 'https://reddit.com/submit'
};

var SocialShareButton =
/*#__PURE__*/
function (_Domodule) {
  _inheritsLoose(SocialShareButton, _Domodule);

  function SocialShareButton() {
    return _Domodule.apply(this, arguments) || this;
  }

  var _proto = SocialShareButton.prototype;

  _proto.postInit = function postInit() {
    var _this = this;

    var setupMethod = this.options.net + "Setup";
    var shareMethod = this.options.net + "Share";

    if (!this[shareMethod] && !this[setupMethod]) {
      throw new Error("Sharing method for " + this.options.net + " is not implemented");
    }

    if (this[setupMethod]) {
      this[setupMethod]();
    }

    if (this[shareMethod]) {
      (0,domassist__WEBPACK_IMPORTED_MODULE_1__.on)(this.el, 'click', function (event) {
        event.preventDefault();

        _this[shareMethod]();
      });
    }
  };

  _proto.getShareUrl = function getShareUrl() {
    var url = window.location.href;

    if (this.options.baseUrl) {
      if (this.options.relative) {
        url = "" + window.location.origin + window.location.pathname + this.options.baseUrl;
      } else {
        url = this.options.baseUrl;
      }
    }

    return url;
  };

  _proto.gplusShare = function gplusShare() {
    SocialShareButton.openWindow(this.el.href, '600', '500', 'gplusWindow');
  };

  _proto.twitterShare = function twitterShare() {
    SocialShareButton.openWindow(this.el.href, '260', '500', 'twitterWindow');
  };

  _proto.linkedinShare = function linkedinShare() {
    SocialShareButton.openWindow(this.el.href, '520', '570', 'linkedinWindow');
  };

  _proto.pinterestShare = function pinterestShare() {
    SocialShareButton.openWindow(this.el.href, '600', '600', 'pinterestWindow');
  };

  _proto.redditShare = function redditShare() {
    SocialShareButton.openWindow(this.el.href, '600', '600', 'redditWindow');
  };

  _proto.facebookShare = function facebookShare() {
    if (typeof window.FB !== 'undefined' && typeof window.FB.ui !== 'undefined') {
      var object = {
        method: 'share',
        href: this.getShareUrl()
      };

      if (this.options.tag) {
        object.hashtag = "#" + this.options.tag;
      }

      if (this.options.text) {
        object.quote = this.options.text;
      }

      FB.ui(object);
    } else {
      SocialShareButton.openWindow(this.el.href, '440', '600', 'facebookWindow');
    }
  };

  _proto.facebookSetup = function facebookSetup() {
    var params = ["u=" + this.getShareUrl()];

    if (this.options.tag) {
      params.push("hashtag=" + encodeURIComponent("#" + this.options.tag));
    }

    if (this.options.text) {
      params.push("quote=" + encodeURIComponent(this.options.text));
    }

    this.el.href = BASE_URLS.facebook + "?" + params.join('&');
  };

  _proto.emailSetup = function emailSetup() {
    var title = encodeURIComponent(this.options.subject || document.title);
    var body = this.options.body || 'Check this out #url';
    body = body.replace(/#url/gi, this.getShareUrl());
    body = encodeURIComponent(body);
    this.el.href = "mailto:?subject=" + title + "&body=" + body;
  };

  _proto.gplusSetup = function gplusSetup() {
    this.el.href = BASE_URLS.gplus + "?url=" + this.getShareUrl();
  };

  _proto.linkedinSetup = function linkedinSetup() {
    var params = ["url=" + encodeURIComponent(this.getShareUrl())];
    var shareText = this.options.text;
    var shareTitle = this.options.title;

    if (shareText) {
      params.push("summary=" + encodeURIComponent(shareText));
    }

    if (shareTitle) {
      params.push("title=" + encodeURIComponent(shareTitle));
    }

    this.el.href = BASE_URLS.linkedin + "?mini=true&" + params.join('&');
  };

  _proto.twitterSetup = function twitterSetup() {
    var shareText = this.options.text || SocialShareButton.getMeta('text', 'twi');
    var shareTag = this.options.tags || SocialShareButton.getMeta('hashtag', 'twi');
    var shareVia = this.options.via || SocialShareButton.getMeta('author', 'twi');
    var params = [];
    params.push("url=" + encodeURIComponent(this.getShareUrl()));

    if (shareText) {
      params.push("text=" + encodeURIComponent(shareText));
    }

    if (shareTag && shareTag !== 'none') {
      params.push("hashtags=" + encodeURIComponent(shareTag));
    }

    if (shareVia && shareVia !== 'none') {
      params.push("via=" + encodeURIComponent(shareVia));
    }

    this.el.href = BASE_URLS.twitter + "?" + params.join('&');
  };

  _proto.pinterestSetup = function pinterestSetup() {
    var shareTitle = this.options.title || SocialShareButton.getMeta('title');
    var shareMedia = this.options.media || SocialShareButton.getMeta('image');
    var params = ["url=" + encodeURIComponent(this.getShareUrl())];

    if (shareTitle) {
      params.push("description=" + encodeURIComponent(shareTitle));
    }

    if (shareMedia) {
      params.push("media=" + encodeURIComponent(shareMedia));
    }

    this.el.href = BASE_URLS.pinterest + "?" + params.join('&');
  };

  _proto.redditSetup = function redditSetup() {
    var shareTitle = this.options.title;
    var params = ["url=" + encodeURIComponent(this.getShareUrl())];

    if (shareTitle) {
      params.push("title=" + encodeURIComponent(shareTitle));
    }

    this.el.href = BASE_URLS.reddit + "?" + params.join('&');
  };

  SocialShareButton.getMeta = function getMeta(tag, prop) {
    if (prop === void 0) {
      prop = 'og';
    }

    var meta = (0,domassist__WEBPACK_IMPORTED_MODULE_1__.findOne)("meta[property=\"" + prop + ":" + tag + "\"]");
    return meta ? meta.getAttribute('content') : null;
  };

  SocialShareButton.openWindow = function openWindow(url, height, width, key) {
    window.open(url, key, "menubar=no,toolbar=no,left=200,top=200,resizable=yes,scrollbars=no,height=" + height + ",width=" + width);
  };

  _createClass(SocialShareButton, [{
    key: "required",
    get: function get() {
      return {
        options: ['net']
      };
    }
  }, {
    key: "defaults",
    get: function get() {
      return {
        relative: false,
        baseUrl: false
      };
    }
  }]);

  return SocialShareButton;
}(domodule__WEBPACK_IMPORTED_MODULE_0__.default);
domodule__WEBPACK_IMPORTED_MODULE_0__.default.register('SocialShareButton', SocialShareButton);

/* harmony default export */ __webpack_exports__["default"] = (SocialShareButton);
//# sourceMappingURL=social-share-button.js.map


/***/ }),

/***/ "./node_modules/svg4everybody/dist/svg4everybody.js":
/*!**********************************************************!*\
  !*** ./node_modules/svg4everybody/dist/svg4everybody.js ***!
  \**********************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(root, factory) {
     true ? // AMD. Register as an anonymous module unless amdModuleId is set
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
        return root.svg4everybody = factory();
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;
}(this, function() {
    /*! svg4everybody v2.1.9 | github.com/jonathantneal/svg4everybody */
    function embed(parent, svg, target) {
        // if the target exists
        if (target) {
            // create a document fragment to hold the contents of the target
            var fragment = document.createDocumentFragment(), viewBox = !svg.hasAttribute("viewBox") && target.getAttribute("viewBox");
            // conditionally set the viewBox on the svg
            viewBox && svg.setAttribute("viewBox", viewBox);
            // copy the contents of the clone into the fragment
            for (// clone the target
            var clone = target.cloneNode(!0); clone.childNodes.length; ) {
                fragment.appendChild(clone.firstChild);
            }
            // append the fragment into the svg
            parent.appendChild(fragment);
        }
    }
    function loadreadystatechange(xhr) {
        // listen to changes in the request
        xhr.onreadystatechange = function() {
            // if the request is ready
            if (4 === xhr.readyState) {
                // get the cached html document
                var cachedDocument = xhr._cachedDocument;
                // ensure the cached html document based on the xhr response
                cachedDocument || (cachedDocument = xhr._cachedDocument = document.implementation.createHTMLDocument(""), 
                cachedDocument.body.innerHTML = xhr.responseText, xhr._cachedTarget = {}), // clear the xhr embeds list and embed each item
                xhr._embeds.splice(0).map(function(item) {
                    // get the cached target
                    var target = xhr._cachedTarget[item.id];
                    // ensure the cached target
                    target || (target = xhr._cachedTarget[item.id] = cachedDocument.getElementById(item.id)), 
                    // embed the target into the svg
                    embed(item.parent, item.svg, target);
                });
            }
        }, // test the ready state change immediately
        xhr.onreadystatechange();
    }
    function svg4everybody(rawopts) {
        function oninterval() {
            // while the index exists in the live <use> collection
            for (// get the cached <use> index
            var index = 0; index < uses.length; ) {
                // get the current <use>
                var use = uses[index], parent = use.parentNode, svg = getSVGAncestor(parent), src = use.getAttribute("xlink:href") || use.getAttribute("href");
                if (!src && opts.attributeName && (src = use.getAttribute(opts.attributeName)), 
                svg && src) {
                    if (polyfill) {
                        if (!opts.validate || opts.validate(src, svg, use)) {
                            // remove the <use> element
                            parent.removeChild(use);
                            // parse the src and get the url and id
                            var srcSplit = src.split("#"), url = srcSplit.shift(), id = srcSplit.join("#");
                            // if the link is external
                            if (url.length) {
                                // get the cached xhr request
                                var xhr = requests[url];
                                // ensure the xhr request exists
                                xhr || (xhr = requests[url] = new XMLHttpRequest(), xhr.open("GET", url), xhr.send(), 
                                xhr._embeds = []), // add the svg and id as an item to the xhr embeds list
                                xhr._embeds.push({
                                    parent: parent,
                                    svg: svg,
                                    id: id
                                }), // prepare the xhr ready state change event
                                loadreadystatechange(xhr);
                            } else {
                                // embed the local id into the svg
                                embed(parent, svg, document.getElementById(id));
                            }
                        } else {
                            // increase the index when the previous value was not "valid"
                            ++index, ++numberOfSvgUseElementsToBypass;
                        }
                    }
                } else {
                    // increase the index when the previous value was not "valid"
                    ++index;
                }
            }
            // continue the interval
            (!uses.length || uses.length - numberOfSvgUseElementsToBypass > 0) && requestAnimationFrame(oninterval, 67);
        }
        var polyfill, opts = Object(rawopts), newerIEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/, webkitUA = /\bAppleWebKit\/(\d+)\b/, olderEdgeUA = /\bEdge\/12\.(\d+)\b/, edgeUA = /\bEdge\/.(\d+)\b/, inIframe = window.top !== window.self;
        polyfill = "polyfill" in opts ? opts.polyfill : newerIEUA.test(navigator.userAgent) || (navigator.userAgent.match(olderEdgeUA) || [])[1] < 10547 || (navigator.userAgent.match(webkitUA) || [])[1] < 537 || edgeUA.test(navigator.userAgent) && inIframe;
        // create xhr requests object
        var requests = {}, requestAnimationFrame = window.requestAnimationFrame || setTimeout, uses = document.getElementsByTagName("use"), numberOfSvgUseElementsToBypass = 0;
        // conditionally start the interval if the polyfill is active
        polyfill && oninterval();
    }
    function getSVGAncestor(node) {
        for (var svg = node; "svg" !== svg.nodeName.toLowerCase() && (svg = svg.parentNode); ) {}
        return svg;
    }
    return svg4everybody;
});

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_zeitiger_appendaround_appendAround_js-node_modules_morphdom_dist_morphdo-a91934-42a0118289ce2af00358.js.map